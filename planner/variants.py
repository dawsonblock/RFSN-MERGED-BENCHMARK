"""Planner variants for upstream learner routing.

These planners generate different plan structures for the LLM patcher.
They do NOT execute code and they do NOT touch the gate.

Design goal:
- Provide materially different plan structures so the PlannerSelector can learn routing.

Available planners:
- planner_traceback_first: Single-file, traceback-local fix bias
- planner_api_compat: Prefers adapter layers + backwards compat patterns
- planner_regression_hunt: Test selection + search over smaller patches
"""

from __future__ import annotations

import re
import uuid
from dataclasses import dataclass, field
from typing import Any


@dataclass
class RepairStep:
    """A single step in a repair plan."""

    intent: str
    files: list[str] = field(default_factory=list)
    hypothesis: str = ""


@dataclass
class Plan:
    """A repair plan generated by a planner variant."""

    task_id: str
    bug_summary: str
    steps: list[RepairStep]
    confidence: float
    metadata: dict[str, Any] = field(default_factory=dict)
    task: dict[str, Any] = field(default_factory=dict)


_FILE_LINE_RE = re.compile(r'File "([^"]+\.py)", line (\d+)')


def _guess_files_from_trace(trace: str, limit: int = 3) -> list[str]:
    """Extract file paths from traceback."""
    if not trace:
        return []
    hits = []
    for m in _FILE_LINE_RE.finditer(trace):
        path = m.group(1).replace("\\", "/")
        # ignore site-packages noise when possible
        if "/site-packages/" in path or "dist-packages" in path:
            continue
        hits.append(path)
    # keep order, unique
    out = []
    for p in hits:
        if p not in out:
            out.append(p)
    return out[:limit]


def _fallback_files(task: dict[str, Any]) -> list[str]:
    """Get fallback files from task metadata."""
    files = task.get("failing_files") or task.get("files") or []
    if isinstance(files, str):
        files = [files]
    return files[:5] if files else ["unknown.py"]


def planner_traceback_first(
    task: dict[str, Any], retrieved_memory: dict[str, Any] | None = None
) -> Plan:
    """Planner: Traceback-first localization.

    Biases toward the top stack frames and line-level evidence.
    Best for: clear stack traces, assertion errors, specific exceptions.
    """
    desc = task.get("description", task.get("problem_statement", "unknown bug"))
    trace = task.get("last_test_output", "") or ""
    files = _guess_files_from_trace(trace) or _fallback_files(task)

    steps = [
        RepairStep(
            intent="Extract the exact failing stack frame and identify the local failing line(s)",
            files=files,
            hypothesis="The bug is near the first non-vendor frame in the traceback.",
        ),
        RepairStep(
            intent="Apply a minimal fix near the failing line(s); avoid refactors",
            files=files,
            hypothesis="A small conditional, import fix, or argument correction resolves the failure.",
        ),
        RepairStep(
            intent="Run targeted tests first, then full suite if improved",
            files=[],
            hypothesis="Fast feedback reduces wasted attempts.",
        ),
    ]

    return Plan(
        task_id=str(uuid.uuid4()),
        bug_summary=desc,
        steps=steps,
        confidence=0.55,
        metadata={"source": "planner_traceback_first"},
        task=task,
    )


def planner_api_compat(
    task: dict[str, Any], retrieved_memory: dict[str, Any] | None = None
) -> Plan:
    """Planner: API-compat / shim strategy.

    Good for AttributeError/TypeError/ImportError/KeyError regressions and version drift.
    Best for: compatibility issues, missing attributes, signature mismatches.
    """
    desc = task.get("description", task.get("problem_statement", "unknown bug"))
    trace = task.get("last_test_output", "") or ""
    files = _guess_files_from_trace(trace) or _fallback_files(task)
    retrieved_memory = retrieved_memory or {}

    steps = [
        RepairStep(
            intent="Determine whether failure is due to API drift (signature/attribute/import changes)",
            files=files,
            hypothesis="An upstream dependency or internal API changed; callers now break.",
        ),
        RepairStep(
            intent="Implement a small compatibility shim or adapter layer (prefer local change)",
            files=files,
            hypothesis="A wrapper/alias keeps both old and new call patterns working.",
        ),
        RepairStep(
            intent="Add defensive handling for missing keys/attrs if failure suggests data-shape drift",
            files=files,
            hypothesis="Guarding None/missing keys prevents regressions without broad changes.",
        ),
    ]

    # if retrieval has a similar fix, surface it as an explicit step
    hits = retrieved_memory.get("similar_failures", []) or []
    if hits:
        best = hits[0]
        steps.insert(
            1,
            RepairStep(
                intent=f"Mirror a known-compatible fix pattern: {best.get('patch_summary', '(no summary)')[:80]}",
                files=files,
                hypothesis=f"Similar failure previously fixed (score={best.get('score', 0):.2f}).",
            ),
        )

    return Plan(
        task_id=str(uuid.uuid4()),
        bug_summary=desc,
        steps=steps,
        confidence=0.50 if hits else 0.40,
        metadata={"source": "planner_api_compat", "retrieval_count": len(hits)},
        task=task,
    )


def planner_regression_hunt(
    task: dict[str, Any], retrieved_memory: dict[str, Any] | None = None
) -> Plan:
    """Planner: Regression hunt.

    Good for subtle test expectations and behavioral mismatches.
    Biases toward narrow changes + invariants from failing tests.
    Best for: behavior regressions, subtle logic bugs, test expectation changes.
    """
    desc = task.get("description", task.get("problem_statement", "unknown bug"))
    trace = task.get("last_test_output", "") or ""
    files = _guess_files_from_trace(trace) or _fallback_files(task)

    steps = [
        RepairStep(
            intent="Infer the contract from failing assertion (inputs/outputs/invariants)",
            files=[],
            hypothesis="The test encodes the correct contract; derive it before changing code.",
        ),
        RepairStep(
            intent="Localize the violating branch and patch only the violating behavior",
            files=files,
            hypothesis="The defect is a small behavioral edge case, not a structural rewrite.",
        ),
        RepairStep(
            intent="Avoid widening behavior; prefer tighter checks to satisfy invariants",
            files=files,
            hypothesis="Tight fixes reduce chance of new failures elsewhere.",
        ),
    ]

    return Plan(
        task_id=str(uuid.uuid4()),
        bug_summary=desc,
        steps=steps,
        confidence=0.45,
        metadata={"source": "planner_regression_hunt"},
        task=task,
    )


# Registry for planner discovery
PLANNER_VARIANTS = {
    "planner_traceback_first": planner_traceback_first,
    "planner_api_compat": planner_api_compat,
    "planner_regression_hunt": planner_regression_hunt,
}
